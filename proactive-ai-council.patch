diff --git a/src/handlers/text.ts b/src/handlers/text.ts
index d91382d..4ff9edf 100644
--- a/src/handlers/text.ts
+++ b/src/handlers/text.ts
@@ -13,6 +13,172 @@ import {
   startTypingIndicator,
 } from "../utils";
 import { StreamingState, createStatusCallback } from "./streaming";
+import { checkAutoRules } from "./auto-rules";
+import {
+  parseRoutePrefix,
+  routeToAI,
+  extractAndSaveMemory,
+  getAIDisplayName,
+  type AIProvider,
+} from "./ai-router";
+import { checkMessageIntent } from "../utils/approval-manager";
+
+/**
+ * Handle AI Router requests (gpt:, gemini:, croppy:, all:, council:)
+ */
+async function handleAIRouterRequest(
+  ctx: Context,
+  provider: AIProvider,
+  prompt: string,
+  userId: number,
+  username: string
+): Promise<void> {
+  const typing = startTypingIndicator(ctx);
+
+  try {
+    const credentialsPath =
+      process.env.GOOGLE_CREDENTIALS_PATH ||
+      "/Users/daijiromatsuokam1/jarvis-docs-credentials.json";
+    const documentId = process.env.AI_MEMORY_DOC_ID || "";
+
+    if (!documentId) {
+      await ctx.reply("âŒ AI_MEMORY_DOC_ID is not configured");
+      return;
+    }
+
+    // AI Routerã§ãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†
+    const response = await routeToAI(provider, prompt, credentialsPath, documentId);
+
+    const displayName = getAIDisplayName(provider);
+
+    // AI Council ã®å ´åˆã¯ç‰¹åˆ¥å‡¦ç†
+    if (provider === 'council' && 'advisorResponses' in response) {
+      // 1. ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ã®æ„è¦‹ã‚’é€ä¿¡
+      await sendLongMessage(ctx, response.advisorResponses);
+
+      // 2. JarvisãŒçµ±åˆåˆ¤æ–­ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
+      const councilPrompt = `ã‚ãªãŸã¯JarvisğŸ¤–ã§ã™ã€‚ä»¥ä¸‹ã®3äººã®AIã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ã®æ„è¦‹ã‚’ç·åˆçš„ã«åˆ¤æ–­ã—ã€æœ€è‰¯ã®å›ç­”ã‚’æä¾›ã—ã¦ãã ã•ã„ã€‚
+
+## ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•
+${prompt}
+
+${response.advisorResponses}
+
+---
+
+ä¸Šè¨˜ã®3äººã®æ„è¦‹ã‚’è¸ã¾ãˆã¦ã€ã‚ãªãŸï¼ˆJarvisï¼‰ã®æœ€çµ‚åˆ¤æ–­ã‚’æç¤ºã—ã¦ãã ã•ã„ã€‚
+- å…±é€šã™ã‚‹è¦‹è§£ãŒã‚ã‚Œã°çµ±åˆ
+- ç•°ãªã‚‹è¦‹è§£ãŒã‚ã‚Œã°æ¯”è¼ƒæ¤œè¨
+- ã‚ãªãŸè‡ªèº«ã®åˆ¤æ–­ã‚’æ˜ç¢ºã«ç¤ºã™`;
+
+      // 3. Jarvisã‚»ãƒƒã‚·ãƒ§ãƒ³ã«é€ä¿¡ï¼ˆé€šå¸¸ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨åŒæ§˜ã«å‡¦ç†ï¼‰
+      const stopProcessing = session.startProcessing();
+      const state = new StreamingState();
+      const statusCallback = createStatusCallback(ctx, state);
+
+      try {
+        const jarvisResponse = await session.sendMessageStreaming(
+          councilPrompt,
+          username,
+          userId,
+          statusCallback,
+          ctx.chat!.id,
+          ctx
+        );
+
+        // Audit log
+        await auditLog(
+          userId,
+          username,
+          "AI_COUNCIL",
+          prompt,
+          `Advisors:\n${response.advisorResponses}\n\nJarvis:\n${jarvisResponse}`
+        );
+      } finally {
+        stopProcessing();
+      }
+
+      return;
+    }
+
+    // é€šå¸¸ã®AIãƒ«ãƒ¼ã‚¿ãƒ¼å¿œç­”
+    if ('error' in response && response.error) {
+      await ctx.reply(`âŒ Error from ${displayName}: ${response.error}`);
+      return;
+    }
+
+    if ('content' in response && !response.content) {
+      await ctx.reply(`âš ï¸ No response from ${displayName}`);
+      return;
+    }
+
+    // Telegramã«çµæœã‚’è¿”ã™ï¼ˆ4096æ–‡å­—åˆ¶é™å¯¾å¿œã§åˆ†å‰²é€ä¿¡ï¼‰
+    const header = provider !== 'all' ? `**${displayName}**\n\n` : '';
+    const content = 'content' in response ? header + response.content : '';
+
+    await sendLongMessage(ctx, content);
+
+    // MEMORYã‚¿ã‚°ãŒã‚ã‚Œã°AI_MEMORYã«ä¿å­˜ï¼ˆåœæ­¢ä¸­ï¼‰
+    // await extractAndSaveMemory(response, credentialsPath, documentId);
+
+    // Audit log
+    await auditLog(
+      userId,
+      username,
+      "AI_ROUTER",
+      `${provider}: ${prompt}`,
+      'content' in response ? response.content : ''
+    );
+  } catch (error) {
+    console.error("[AI Router] Error:", error);
+    await ctx.reply(`âŒ AI Router error: ${String(error).slice(0, 200)}`);
+  } finally {
+    typing.stop();
+  }
+}
+
+/**
+ * é•·ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’4096æ–‡å­—åˆ¶é™ã«å¯¾å¿œã—ã¦åˆ†å‰²é€ä¿¡
+ */
+async function sendLongMessage(ctx: Context, content: string): Promise<void> {
+  const maxLength = 4000; // å°‘ã—ä½™è£•ã‚’æŒãŸã›ã‚‹
+
+  if (content.length <= maxLength) {
+    await ctx.reply(content);
+    return;
+  }
+
+  // é•·ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’åˆ†å‰²
+  const chunks: string[] = [];
+  let remaining = content;
+
+  while (remaining.length > 0) {
+    if (remaining.length <= maxLength) {
+      chunks.push(remaining);
+      break;
+    }
+
+    // æ”¹è¡Œä½ç½®ã§åˆ†å‰²ã‚’è©¦ã¿ã‚‹
+    let splitIndex = remaining.lastIndexOf('\n', maxLength);
+    if (splitIndex < maxLength / 2) {
+      // è‰¯ã„åˆ†å‰²ç‚¹ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ã‚¹ãƒšãƒ¼ã‚¹ã§åˆ†å‰²
+      splitIndex = remaining.lastIndexOf(' ', maxLength);
+    }
+    if (splitIndex < maxLength / 2) {
+      // ãã‚Œã§ã‚‚è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€å¼·åˆ¶åˆ†å‰²
+      splitIndex = maxLength;
+    }
+
+    chunks.push(remaining.slice(0, splitIndex));
+    remaining = remaining.slice(splitIndex).trimStart();
+  }
+
+  // åˆ†å‰²ã—ã¦é€ä¿¡
+  for (let i = 0; i < chunks.length; i++) {
+    const header = chunks.length > 1 ? `(${i + 1}/${chunks.length})\n` : '';
+    await ctx.reply(header + chunks[i]);
+  }
+}
 
 /**
  * Handle incoming text messages.
@@ -39,7 +205,33 @@ export async function handleText(ctx: Context): Promise<void> {
     return;
   }
 
-  // 3. Rate limit check
+  // 3. Check AI Router prefix (gpt:, gemini:, croppy:, all:, council:)
+  const route = parseRoutePrefix(message);
+  if (route.provider !== 'jarvis') {
+    // Route to specific AI
+    await handleAIRouterRequest(ctx, route.provider, route.prompt, userId, username);
+    return;
+  }
+
+  // 4. Check for dangerous intent in user message
+  await checkMessageIntent(ctx, message);
+
+  // 5. Check auto-execution rules from CLAUDE.md (including AI Council consultation)
+  const ruleMatched = await checkAutoRules(ctx, message);
+  if (ruleMatched) {
+    // Rule was executed, don't send to Claude
+    return;
+  }
+
+  // 5.5. Check if AI Council advice is available (from pre-implementation consultation)
+  let enhancedMessage = message;
+  if ((ctx as any).aiCouncilAdvice) {
+    const advice = (ctx as any).aiCouncilAdvice;
+    enhancedMessage = `[AI Councilã‹ã‚‰ã®äº‹å‰åŠ©è¨€]\n${advice}\n\n---\n\n[ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ]\n${message}`;
+    console.log('[Text Handler] Using AI Council advice in message');
+  }
+
+  // 6. Rate limit check
   const [allowed, retryAfter] = rateLimiter.check(userId);
   if (!allowed) {
     await auditLogRateLimit(userId, username, retryAfter!);
@@ -49,10 +241,10 @@ export async function handleText(ctx: Context): Promise<void> {
     return;
   }
 
-  // 4. Store message for retry
+  // 7. Store message for retry
   session.lastMessage = message;
 
-  // 5. Set conversation title from first message (if new session)
+  // 8. Set conversation title from first message (if new session)
   if (!session.isActive) {
     // Truncate title to ~50 chars
     const title =
@@ -60,23 +252,23 @@ export async function handleText(ctx: Context): Promise<void> {
     session.conversationTitle = title;
   }
 
-  // 6. Mark processing started
+  // 9. Mark processing started
   const stopProcessing = session.startProcessing();
 
-  // 7. Start typing indicator
+  // 10. Start typing indicator
   const typing = startTypingIndicator(ctx);
 
-  // 8. Create streaming state and callback
+  // 11. Create streaming state and callback
   let state = new StreamingState();
   let statusCallback = createStatusCallback(ctx, state);
 
-  // 9. Send to Claude with retry logic for crashes
+  // 12. Send to Claude with retry logic for crashes
   const MAX_RETRIES = 1;
 
   for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
     try {
       const response = await session.sendMessageStreaming(
-        message,
+        enhancedMessage, // Use enhanced message with AI Council advice if available
         username,
         userId,
         statusCallback,
@@ -84,7 +276,7 @@ export async function handleText(ctx: Context): Promise<void> {
         ctx
       );
 
-      // 10. Audit log
+      // 13. Audit log
       await auditLog(userId, username, "TEXT", message, response);
       break; // Success - exit retry loop
     } catch (error) {
@@ -106,7 +298,9 @@ export async function handleText(ctx: Context): Promise<void> {
           `Claude Code crashed, retrying (attempt ${attempt + 2}/${MAX_RETRIES + 1})...`
         );
         await session.kill(); // Clear corrupted session
-        await ctx.reply(`âš ï¸ Claude crashed, retrying...`);
+        await ctx.reply(`âš ï¸ Claude crashed, retrying...`, {
+          disable_notification: true, // Silent notification for retry status
+        });
         // Reset state for retry
         state = new StreamingState();
         statusCallback = createStatusCallback(ctx, state);
@@ -130,7 +324,7 @@ export async function handleText(ctx: Context): Promise<void> {
     }
   }
 
-  // 11. Cleanup
+  // 14. Cleanup
   stopProcessing();
   typing.stop();
 }
